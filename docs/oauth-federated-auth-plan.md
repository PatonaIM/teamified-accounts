# OAuth 2.0 / OIDC Federated Authentication Implementation Plan

**Project Goal:** Transform the Teamified EOR Portal into an OAuth 2.0 / OpenID Connect Identity Provider for 3 internal Replit web applications.

**Document Version:** 1.0  
**Created:** November 5, 2025  
**Status:** Planning Phase

---

## Executive Summary

This plan outlines the implementation of federated authentication, enabling the Teamified Portal to act as a centralized identity provider for multiple internal applications. The solution leverages existing JWT infrastructure while adding OAuth 2.0 and OIDC protocols for secure, standardized authentication flows.

### Key Benefits
- **Single Sign-On (SSO)** across all internal apps
- **Centralized user management** with consistent role-based access
- **Secure token-based authentication** using industry standards
- **Scope-based permissions** for fine-grained access control
- **Reduced development overhead** for new applications

---

## Current Architecture Assessment

### ‚úÖ Existing Infrastructure (Ready to Use)

1. **JWT Token System**
   - Token generation/validation (`JwtTokenService`)
   - Access tokens (15min expiry) with user claims
   - Refresh tokens (30-day expiry) with token families
   - Token rotation and revocation support

2. **User Management**
   - User entity with profiles stored in PostgreSQL
   - Role-based access control (RBAC)
   - Multi-tenant support with client scoping
   - Session management with Redis

3. **Security Features**
   - Argon2 password hashing
   - Multi-tier rate limiting
   - Audit logging for all entity changes
   - Environment-aware CORS configuration

### üîß Required Additions

1. OAuth 2.0 authorization server
2. Client application registration system
3. User consent flow and UI
4. OIDC discovery endpoints
5. Scope-based permission mapping
6. Token revocation mechanisms

---

## Implementation Phases

### Phase 1: Foundation - OAuth Client Management

**Objective:** Build infrastructure to register and manage client applications that can authenticate through the portal.

#### Task 1.1: Create OAuth Client Entity

**Database Schema:**
```typescript
OAuthClient {
  clientId: string (UUID, primary key)
  clientSecret: string (hashed, for confidential clients)
  name: string (app name, e.g., "HR Analytics Dashboard")
  description: string (optional)
  redirectUris: string[] (allowed callback URLs)
  allowedScopes: string[] (e.g., ['profile', 'email', 'roles:read'])
  clientType: 'confidential' | 'public'
  isActive: boolean
  createdBy: string (admin user ID)
  createdAt: timestamp
  updatedAt: timestamp
}
```

**Implementation Notes:**
- Use UUID v4 for `clientId`
- Hash `clientSecret` with Argon2 (same as passwords)
- Validate redirect URIs on registration (must be HTTPS in production)
- Support multiple redirect URIs per client for different environments

#### Task 1.2: Client Registration UI (Admin Only)

**Admin Portal Features:**
- Page: `/admin/oauth-clients`
- List all registered client applications
- "Register New Client" form with fields:
  - Application name
  - Description
  - Redirect URI(s) (textarea, one per line)
  - Allowed scopes (multi-select)
  - Client type (confidential/public)
- Display credentials securely:
  - Show `clientSecret` only once on creation
  - Provide "Copy to Clipboard" buttons
  - Warn user to save credentials immediately
- Edit/deactivate clients
- View usage statistics (total authorizations, last used)

**Role Requirement:** Admin only

#### Task 1.3: Client Management Service

**Core Methods:**
```typescript
class OAuthClientService {
  validateClient(clientId: string, clientSecret?: string): Promise<OAuthClient>
  validateRedirectUri(clientId: string, redirectUri: string): Promise<boolean>
  validateScopes(clientId: string, requestedScopes: string[]): Promise<boolean>
  rotateClientSecret(clientId: string): Promise<string>
  deactivateClient(clientId: string): Promise<void>
}
```

**Security Considerations:**
- Constant-time comparison for client secret validation
- Log all client authentication attempts
- Rate limit client validation endpoints

---

### Phase 2: OAuth 2.0 Authorization Server

**Objective:** Implement the OAuth 2.0 Authorization Code Flow with PKCE support.

#### Task 2.1: Authorization Endpoint

**Endpoint:** `GET /oauth/authorize`

**Query Parameters:**
- `client_id` (required) - Registered client identifier
- `redirect_uri` (required) - Callback URL (must match registered URI)
- `response_type` (required) - Must be "code"
- `scope` (optional) - Space-separated list of scopes
- `state` (required) - CSRF protection token (generated by client)
- `code_challenge` (optional, required for public clients) - PKCE challenge
- `code_challenge_method` (optional) - "S256" or "plain"

**Flow:**
1. Validate client_id exists and is active
2. Validate redirect_uri matches registered URIs
3. Validate requested scopes are allowed for client
4. Check if user is authenticated (redirect to login if not)
5. Check if user previously consented (skip consent if yes)
6. Show consent screen (if needed)
7. Generate authorization code (6-character alphanumeric, 10min expiry)
8. Store code with: userId, clientId, scopes, codeChallenge, redirectUri
9. Redirect to `redirect_uri?code={code}&state={state}`

**Error Handling:**
- Invalid client ‚Üí 400 Bad Request
- Mismatched redirect_uri ‚Üí 400 Bad Request (do NOT redirect)
- User denies consent ‚Üí redirect to `redirect_uri?error=access_denied&state={state}`

#### Task 2.2: Token Endpoint

**Endpoint:** `POST /oauth/token`

**Grant Type: authorization_code**

**Request Body (application/x-www-form-urlencoded):**
```
grant_type=authorization_code
code={authorization_code}
redirect_uri={same_as_authorize_request}
client_id={client_id}
client_secret={client_secret} (for confidential clients)
code_verifier={verifier} (for PKCE)
```

**Response (200 OK):**
```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 900,
  "refresh_token": "rt_abc123...",
  "scope": "openid profile email roles:read",
  "id_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9..." (if openid scope requested)
}
```

**Grant Type: refresh_token**

**Request Body:**
```
grant_type=refresh_token
refresh_token={refresh_token}
client_id={client_id}
client_secret={client_secret} (for confidential clients)
scope={optional_reduced_scopes}
```

**Validation Steps:**
1. Verify client credentials
2. Verify authorization code is valid, not expired, not used
3. Verify redirect_uri matches original request
4. Verify code_verifier matches code_challenge (if PKCE)
5. Mark code as used (prevent replay)
6. Generate access token + refresh token
7. Store refresh token in session table
8. Return token response

#### Task 2.3: PKCE Support

**Proof Key for Code Exchange (RFC 7636)**

**Authorization Request:**
- Client generates random `code_verifier` (43-128 characters)
- Client creates `code_challenge = BASE64URL(SHA256(code_verifier))`
- Client sends `code_challenge` + `code_challenge_method=S256` with authorize request

**Token Request:**
- Client sends original `code_verifier`
- Server verifies: `SHA256(code_verifier) === stored_code_challenge`

**Why PKCE?**
- Protects against authorization code interception attacks
- Required for public clients (SPAs, mobile apps)
- Recommended for all clients as defense-in-depth

#### Task 2.4: Authorization Code Entity

**Database Schema:**
```typescript
AuthorizationCode {
  id: string (UUID)
  code: string (hashed, 6-character alphanumeric)
  userId: string (FK to users)
  clientId: string (FK to oauth_clients)
  scopes: string[]
  redirectUri: string
  codeChallenge: string (optional, for PKCE)
  codeChallengeMethod: 'S256' | 'plain' (optional)
  expiresAt: timestamp (10 minutes from creation)
  used: boolean (default false)
  usedAt: timestamp (nullable)
  createdAt: timestamp
}
```

**Indexes:**
- `code` (unique, for fast lookup)
- `userId` (for user token management)
- `expiresAt` (for cleanup job)

**Cleanup Strategy:**
- Delete codes older than 1 hour (cron job)

---

### Phase 3: OpenID Connect (OIDC) Layer

**Objective:** Add OIDC protocol on top of OAuth 2.0 for standardized identity federation.

#### Task 3.1: OIDC Discovery Endpoint

**Endpoint:** `GET /.well-known/openid-configuration`

**Response (200 OK):**
```json
{
  "issuer": "https://teamified-portal.repl.co",
  "authorization_endpoint": "https://teamified-portal.repl.co/oauth/authorize",
  "token_endpoint": "https://teamified-portal.repl.co/oauth/token",
  "userinfo_endpoint": "https://teamified-portal.repl.co/oauth/userinfo",
  "jwks_uri": "https://teamified-portal.repl.co/oauth/jwks",
  "revocation_endpoint": "https://teamified-portal.repl.co/oauth/revoke",
  "scopes_supported": [
    "openid",
    "profile",
    "email",
    "roles",
    "employment:read",
    "documents:read",
    "timesheets:write"
  ],
  "response_types_supported": ["code"],
  "response_modes_supported": ["query"],
  "grant_types_supported": ["authorization_code", "refresh_token"],
  "subject_types_supported": ["public"],
  "id_token_signing_alg_values_supported": ["RS256"],
  "token_endpoint_auth_methods_supported": ["client_secret_post", "client_secret_basic"],
  "code_challenge_methods_supported": ["S256"],
  "claims_supported": [
    "sub",
    "email",
    "email_verified",
    "name",
    "given_name",
    "family_name",
    "roles",
    "client_id"
  ]
}
```

**Purpose:**
- Auto-discovery for OIDC clients
- Reduces manual configuration
- Industry standard (RFC 8414)

#### Task 3.2: UserInfo Endpoint

**Endpoint:** `GET /oauth/userinfo`

**Authentication:** Bearer token in Authorization header

**Response (200 OK):**
```json
{
  "sub": "550e8400-e29b-41d4-a716-446655440000",
  "email": "john.doe@example.com",
  "email_verified": true,
  "name": "John Doe",
  "given_name": "John",
  "family_name": "Doe",
  "roles": ["eor", "candidate"],
  "client_id": "client-123"
}
```

**Scope Mapping:**
- `openid` ‚Üí `sub`
- `profile` ‚Üí `name`, `given_name`, `family_name`
- `email` ‚Üí `email`, `email_verified`
- `roles` ‚Üí `roles`, `client_id`

**Implementation Notes:**
- Extract access token from Authorization header
- Validate token signature and expiry
- Return only claims allowed by token scopes
- Return 401 if token is invalid/expired

#### Task 3.3: ID Token Generation

**ID Token Structure (JWT):**
```json
{
  "iss": "https://teamified-portal.repl.co",
  "sub": "550e8400-e29b-41d4-a716-446655440000",
  "aud": "client_id_123",
  "exp": 1730851200,
  "iat": 1730850300,
  "nonce": "abc123" (if provided in auth request),
  "email": "john.doe@example.com",
  "email_verified": true,
  "name": "John Doe",
  "roles": ["eor"]
}
```

**Signing:**
- Algorithm: RS256 (RSA with SHA-256)
- Generate RSA key pair (2048-bit minimum)
- Store private key securely (environment variable or secret manager)
- Expose public key via JWKS endpoint

**When to Issue:**
- Only if `openid` scope is requested
- Include in token endpoint response as `id_token` field

#### Task 3.4: JWKS Endpoint

**Endpoint:** `GET /oauth/jwks`

**Response (200 OK):**
```json
{
  "keys": [
    {
      "kty": "RSA",
      "use": "sig",
      "kid": "2024-11-05",
      "n": "xGOr-H7A...",
      "e": "AQAB",
      "alg": "RS256"
    }
  ]
}
```

**Purpose:**
- Client apps verify ID token signatures without shared secrets
- Supports key rotation (multiple keys with `kid` identifier)

**Implementation:**
- Generate RSA key pair on server startup
- Cache public key in memory
- Implement key rotation strategy (rotate every 90 days)

---

### Phase 4: Consent & Authorization UI

**Objective:** Build user-facing screens for granting permissions to client applications.

#### Task 4.1: Consent Screen Page

**Route:** `/oauth/consent`

**UI Elements:**
1. **Header**
   - "Authorize Application"
   - Client app name (bold, large)
   - Client app description

2. **User Info Card**
   - "You are logged in as:"
   - User's name and email
   - Profile photo (if available)
   - "Not you? Logout" link

3. **Permissions Section**
   - "This application would like to:"
   - List of requested scopes with friendly descriptions:
     - ‚úì View your profile information (name, photo)
     - ‚úì Access your email address
     - ‚úì Read your role and employment status
     - ‚úì Submit timesheets on your behalf
   
4. **Action Buttons**
   - "Allow" (primary button)
   - "Deny" (secondary button)

5. **Footer**
   - "By clicking Allow, you authorize {app_name} to access your information"
   - Link to privacy policy

**Mobile Responsive:** Yes

**Security:**
- Display warning if scopes include write permissions
- Show "Remember this choice" checkbox (optional)
- CSRF token in form

#### Task 4.2: Authorization Management Page

**Route:** `/settings/authorized-apps`

**Features:**
1. **List of Authorized Apps**
   - Card for each authorized application
   - App name, description
   - Scopes granted
   - Date authorized
   - Last accessed timestamp

2. **Revoke Access Button**
   - "Revoke Access" button per app
   - Confirmation modal: "Are you sure? This will log you out of {app_name}"
   - Revoke all tokens for that client

3. **Empty State**
   - "You haven't authorized any applications yet"
   - Explanation of what this page shows

#### Task 4.3: User Consent Storage

**Database Schema:**
```typescript
UserConsent {
  id: string (UUID)
  userId: string (FK to users)
  clientId: string (FK to oauth_clients)
  scopes: string[]
  grantedAt: timestamp
  lastAccessedAt: timestamp (updated on each token refresh)
  revokedAt: timestamp (nullable)
}
```

**Logic:**
- Check consent table before showing consent screen
- If consent exists and scopes match ‚Üí skip consent screen
- If consent exists but new scopes requested ‚Üí show consent screen
- Update `lastAccessedAt` on each token refresh

---

### Phase 5: Scope System

**Objective:** Define granular permissions and map them to user roles and claims.

#### Task 5.1: Define Scopes

**Standard OIDC Scopes:**

| Scope | Description | Claims Returned |
|-------|-------------|-----------------|
| `openid` | Required for OIDC | `sub` |
| `profile` | Basic profile info | `name`, `given_name`, `family_name` |
| `email` | Email address | `email`, `email_verified` |

**Custom Portal Scopes:**

| Scope | Description | Required Roles | Claims/Access |
|-------|-------------|----------------|---------------|
| `roles` | Read user roles | All | `roles`, `client_id` |
| `employment:read` | View employment records | All | Access to employment history API |
| `employment:write` | Modify employment records | Admin, HR | Create/update employment records |
| `payroll:read` | View payroll data | Admin, Payroll Admin, Account Manager | Access to payslips, salary history |
| `documents:read` | View documents | All | Access to documents API |
| `documents:write` | Upload documents | All | Upload new documents |
| `timesheets:read` | View timesheets | All | Access to timesheet entries |
| `timesheets:write` | Submit timesheets | EOR, Admin, HR | Create/update timesheet entries |
| `leave:read` | View leave records | All | Access to leave balances |
| `leave:write` | Submit leave requests | EOR, Candidate | Create leave applications |
| `hiring:read` | View job postings | All | Access to job requests, interviews |
| `hiring:write` | Manage hiring | Admin, HR, Recruiter | Create/edit job postings |
| `users:read` | View user profiles | Admin, HR, Account Manager | Access to user list |
| `users:write` | Manage users | Admin | Create/update/delete users |

#### Task 5.2: Scope Validation Service

**Core Logic:**
```typescript
class ScopeValidationService {
  // Validate if user's role allows requesting this scope
  canUserRequestScope(user: User, scope: string): boolean {
    const scopeRoleMap = {
      'payroll:read': ['admin', 'payroll_admin', 'account_manager'],
      'employment:write': ['admin', 'hr', 'hr_manager_client'],
      'users:write': ['admin'],
      // ... etc
    };
    
    const requiredRoles = scopeRoleMap[scope];
    if (!requiredRoles) return true; // Public scope
    
    return user.roles.some(role => requiredRoles.includes(role));
  }
  
  // Filter scopes based on user's permissions
  filterAllowedScopes(user: User, requestedScopes: string[]): string[] {
    return requestedScopes.filter(scope => 
      this.canUserRequestScope(user, scope)
    );
  }
  
  // Get friendly description for consent screen
  getScopeDescription(scope: string): string {
    const descriptions = {
      'openid': 'Verify your identity',
      'profile': 'View your profile information (name, photo)',
      'email': 'Access your email address',
      'roles': 'View your role and permissions',
      'employment:read': 'View your employment history and current status',
      'payroll:read': 'Access your salary and payslip information',
      'timesheets:write': 'Submit and manage timesheets on your behalf',
      // ... etc
    };
    return descriptions[scope] || scope;
  }
}
```

#### Task 5.3: Token Claims Filtering

**Access Token Enhancement:**
```json
{
  "sub": "user-id",
  "email": "user@example.com",
  "roles": ["eor", "candidate"],
  "scope": "openid profile email roles employment:read",
  "client_id": "app-123",
  "iat": 1730850300,
  "exp": 1730851200,
  "jti": "token-id"
}
```

**UserInfo Response Filtering:**
- Parse `scope` claim from access token
- Return only claims allowed by those scopes
- Example: If token has `profile email` scopes, return name + email, but NOT roles

---

### Phase 6: Security Enhancements

**Objective:** Harden the OAuth implementation against common attacks.

#### Task 6.1: Rate Limiting

**OAuth-Specific Limits:**

| Endpoint | Limit | Window | Identifier |
|----------|-------|--------|------------|
| `/oauth/authorize` | 20 requests | 1 minute | User ID |
| `/oauth/token` | 10 requests | 1 minute | Client ID |
| `/oauth/userinfo` | 60 requests | 1 minute | Access Token |
| `/oauth/revoke` | 5 requests | 1 minute | Client ID |

**Implementation:**
- Use existing `@nestjs/throttler` package
- Apply decorators to OAuth controllers
- Return 429 Too Many Requests with Retry-After header

#### Task 6.2: Audit Logging

**Events to Log:**

| Event | Severity | Fields |
|-------|----------|--------|
| Client authorization granted | INFO | userId, clientId, scopes, timestamp |
| Client authorization denied | INFO | userId, clientId, reason |
| Access token issued | INFO | userId, clientId, scopes, expiresAt |
| Refresh token issued | INFO | userId, clientId, tokenFamily |
| Token revoked | WARN | userId, clientId, reason |
| Failed client authentication | WARN | clientId, ipAddress, reason |
| Authorization code reused | ERROR | code, clientId, ipAddress |
| Invalid redirect URI | ERROR | clientId, attemptedUri |

**Storage:**
- Use existing `AuditService`
- Add new entity type: `OAUTH_EVENT`
- Retention: 90 days minimum

#### Task 6.3: Client Secret Rotation

**Admin UI Feature:**
- Button: "Rotate Client Secret"
- Shows warning: "Current secret will be invalid immediately"
- Generates new secret, invalidates old
- Displays new secret only once
- Sends email notification to app owner

**Implementation:**
```typescript
async rotateClientSecret(clientId: string, adminUserId: string): Promise<string> {
  const newSecret = crypto.randomBytes(32).toString('hex');
  const hashedSecret = await argon2.hash(newSecret);
  
  await this.oauthClientRepo.update(clientId, {
    clientSecret: hashedSecret,
    secretRotatedAt: new Date(),
    secretRotatedBy: adminUserId
  });
  
  await this.auditService.log({
    entityType: 'OAUTH_CLIENT',
    entityId: clientId,
    action: 'SECRET_ROTATED',
    performedBy: adminUserId
  });
  
  // Notify app owner
  await this.emailService.sendClientSecretRotatedEmail(clientId);
  
  return newSecret; // Show only once
}
```

#### Task 6.4: Token Revocation Endpoint

**Endpoint:** `POST /oauth/revoke`

**Request Body (application/x-www-form-urlencoded):**
```
token={access_token_or_refresh_token}
token_type_hint={access_token|refresh_token} (optional)
client_id={client_id}
client_secret={client_secret}
```

**Response:** 200 OK (empty body, even if token already invalid)

**Implementation:**
1. Authenticate client (verify client_id + client_secret)
2. Decode token to get `jti` (token ID)
3. Add `jti` to revocation list (Redis set with expiry)
4. If refresh token ‚Üí invalidate entire token family
5. Return 200 OK

**Token Validation Enhancement:**
- Check revocation list before accepting token
- Use Redis for fast lookup
- Set TTL = original token expiry

---

### Phase 7: Client App Integration Guide

**Objective:** Provide documentation and tools for integrating the 3 client apps.

#### Task 7.1: Developer Documentation

**Create:** `/docs/oauth-integration-guide.md`

**Sections:**
1. **Quick Start**
   - Register your app (get client_id + client_secret)
   - Configure redirect URI
   - Implement OAuth flow

2. **OAuth Flow Diagram**
   ```
   [User] ‚Üí [Your App] ‚Üí [Portal /oauth/authorize]
                              ‚Üì (user consents)
   [User] ‚Üê [Your App] ‚Üê [Portal redirects with code]
                              ‚Üì
   [Your App] ‚Üí [Portal /oauth/token] (exchange code for tokens)
                              ‚Üì
   [Your App] ‚Üê [Portal] (returns access_token, refresh_token, id_token)
                              ‚Üì
   [Your App] ‚Üí [Portal /oauth/userinfo] (get user profile)
   ```

3. **Step-by-Step Integration**
   - Authorization request
   - Handling callback
   - Token exchange
   - Using access tokens
   - Refreshing tokens
   - Handling logout

4. **Code Examples**
   - React example (with hooks)
   - Express.js middleware example
   - Axios interceptor example

5. **Scope Reference Table**
   - List all available scopes
   - What data each scope provides
   - Required roles

6. **Error Codes**
   - `invalid_request`
   - `unauthorized_client`
   - `access_denied`
   - `unsupported_response_type`
   - `invalid_scope`
   - `server_error`
   - `temporarily_unavailable`

7. **Security Best Practices**
   - Always use PKCE
   - Validate state parameter
   - Store tokens securely (httpOnly cookies recommended)
   - Never expose client_secret in frontend code
   - Use HTTPS in production

#### Task 7.2: React/TypeScript Client Library

**Create:** `packages/teamified-auth-client/`

**Hook Implementation:**
```typescript
// useTeamifiedAuth.ts
export interface TeamifiedAuthConfig {
  clientId: string;
  redirectUri: string;
  scopes: string[];
  portalUrl: string;
}

export function useTeamifiedAuth(config: TeamifiedAuthConfig) {
  const [user, setUser] = useState<User | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const login = () => {
    const state = generateRandomString();
    const codeVerifier = generateCodeVerifier();
    const codeChallenge = await generateCodeChallenge(codeVerifier);
    
    sessionStorage.setItem('oauth_state', state);
    sessionStorage.setItem('oauth_code_verifier', codeVerifier);
    
    const authUrl = new URL(`${config.portalUrl}/oauth/authorize`);
    authUrl.searchParams.set('client_id', config.clientId);
    authUrl.searchParams.set('redirect_uri', config.redirectUri);
    authUrl.searchParams.set('response_type', 'code');
    authUrl.searchParams.set('scope', config.scopes.join(' '));
    authUrl.searchParams.set('state', state);
    authUrl.searchParams.set('code_challenge', codeChallenge);
    authUrl.searchParams.set('code_challenge_method', 'S256');
    
    window.location.href = authUrl.toString();
  };

  const handleCallback = async () => {
    const params = new URLSearchParams(window.location.search);
    const code = params.get('code');
    const state = params.get('state');
    
    const savedState = sessionStorage.getItem('oauth_state');
    if (state !== savedState) {
      throw new Error('Invalid state parameter');
    }
    
    const codeVerifier = sessionStorage.getItem('oauth_code_verifier');
    
    const tokenResponse = await fetch(`${config.portalUrl}/oauth/token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code: code!,
        redirect_uri: config.redirectUri,
        client_id: config.clientId,
        code_verifier: codeVerifier!
      })
    });
    
    const tokens = await tokenResponse.json();
    
    // Store tokens securely
    sessionStorage.setItem('access_token', tokens.access_token);
    sessionStorage.setItem('refresh_token', tokens.refresh_token);
    
    // Fetch user info
    await fetchUserInfo();
  };

  const fetchUserInfo = async () => {
    const accessToken = sessionStorage.getItem('access_token');
    const response = await fetch(`${config.portalUrl}/oauth/userinfo`, {
      headers: { 'Authorization': `Bearer ${accessToken}` }
    });
    const userData = await response.json();
    setUser(userData);
    setIsAuthenticated(true);
  };

  const logout = () => {
    sessionStorage.clear();
    setUser(null);
    setIsAuthenticated(false);
  };

  return { user, isAuthenticated, isLoading, error, login, logout, handleCallback };
}
```

**Package.json:**
```json
{
  "name": "@teamified/auth-client",
  "version": "1.0.0",
  "description": "OAuth client library for Teamified Portal",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "scripts": {
    "build": "tsc"
  },
  "peerDependencies": {
    "react": "^18.0.0 || ^19.0.0"
  }
}
```

#### Task 7.3: Sample Integration App

**Create:** `examples/sample-oauth-app/`

**Features:**
1. Minimal React app demonstrating OAuth flow
2. Login button ‚Üí redirects to portal
3. Callback handler page
4. Display user info after authentication
5. "Protected Route" example
6. Logout button

**File Structure:**
```
sample-oauth-app/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ App.tsx
‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HomePage.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CallbackPage.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DashboardPage.tsx
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginButton.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProtectedRoute.tsx
‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ       ‚îî‚îÄ‚îÄ useAuth.ts
‚îú‚îÄ‚îÄ .env.example
‚îî‚îÄ‚îÄ README.md
```

**.env.example:**
```
VITE_PORTAL_URL=https://teamified-portal.repl.co
VITE_CLIENT_ID=your_client_id_here
VITE_REDIRECT_URI=https://your-app.repl.co/callback
VITE_SCOPES=openid profile email roles
```

---

## Database Schema Summary

### New Tables

#### 1. `oauth_clients`
```sql
CREATE TABLE oauth_clients (
  client_id VARCHAR(36) PRIMARY KEY,
  client_secret VARCHAR(255) NOT NULL, -- Argon2 hashed
  name VARCHAR(255) NOT NULL,
  description TEXT,
  redirect_uris TEXT[] NOT NULL,
  allowed_scopes TEXT[] NOT NULL,
  client_type VARCHAR(20) NOT NULL CHECK (client_type IN ('confidential', 'public')),
  is_active BOOLEAN DEFAULT TRUE,
  created_by VARCHAR(36) REFERENCES users(id),
  secret_rotated_at TIMESTAMP,
  secret_rotated_by VARCHAR(36) REFERENCES users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_oauth_clients_created_by ON oauth_clients(created_by);
```

#### 2. `authorization_codes`
```sql
CREATE TABLE authorization_codes (
  id VARCHAR(36) PRIMARY KEY,
  code VARCHAR(255) NOT NULL UNIQUE, -- Hashed
  user_id VARCHAR(36) NOT NULL REFERENCES users(id),
  client_id VARCHAR(36) NOT NULL REFERENCES oauth_clients(client_id),
  scopes TEXT[] NOT NULL,
  redirect_uri TEXT NOT NULL,
  code_challenge VARCHAR(255), -- For PKCE
  code_challenge_method VARCHAR(10), -- 'S256' or 'plain'
  nonce VARCHAR(255), -- For OIDC
  expires_at TIMESTAMP NOT NULL,
  used BOOLEAN DEFAULT FALSE,
  used_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_auth_codes_code ON authorization_codes(code);
CREATE INDEX idx_auth_codes_user_id ON authorization_codes(user_id);
CREATE INDEX idx_auth_codes_expires_at ON authorization_codes(expires_at);
```

#### 3. `user_consents`
```sql
CREATE TABLE user_consents (
  id VARCHAR(36) PRIMARY KEY,
  user_id VARCHAR(36) NOT NULL REFERENCES users(id),
  client_id VARCHAR(36) NOT NULL REFERENCES oauth_clients(client_id),
  scopes TEXT[] NOT NULL,
  granted_at TIMESTAMP DEFAULT NOW(),
  last_accessed_at TIMESTAMP DEFAULT NOW(),
  revoked_at TIMESTAMP,
  UNIQUE(user_id, client_id)
);

CREATE INDEX idx_user_consents_user_id ON user_consents(user_id);
CREATE INDEX idx_user_consents_client_id ON user_consents(client_id);
```

#### 4. `oauth_tokens` (for revocation tracking)
```sql
CREATE TABLE oauth_tokens (
  jti VARCHAR(36) PRIMARY KEY, -- Token ID from JWT
  user_id VARCHAR(36) NOT NULL REFERENCES users(id),
  client_id VARCHAR(36) NOT NULL REFERENCES oauth_clients(client_id),
  token_type VARCHAR(20) NOT NULL CHECK (token_type IN ('access', 'refresh')),
  scopes TEXT[],
  revoked_at TIMESTAMP,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_oauth_tokens_jti ON oauth_tokens(jti);
CREATE INDEX idx_oauth_tokens_user_client ON oauth_tokens(user_id, client_id);
CREATE INDEX idx_oauth_tokens_expires_at ON oauth_tokens(expires_at);
```

---

## Technical Implementation Details

### Technology Stack

**No New Dependencies Required:**
- OAuth 2.0 server: Custom NestJS implementation
- JWT signing: Existing `@nestjs/jwt`
- Token storage: Existing PostgreSQL + Redis
- Client credentials: Existing Argon2 hashing

**Optional Dependencies (for enhanced security):**
```bash
npm install --save-dev @types/crypto
# crypto module is Node.js built-in, no installation needed
```

### RSA Key Pair Generation

**For RS256 JWT Signing:**

```typescript
// scripts/generate-rsa-keys.ts
import * as crypto from 'crypto';
import * as fs from 'fs';

const { privateKey, publicKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,
  publicKeyEncoding: {
    type: 'spki',
    format: 'pem'
  },
  privateKeyEncoding: {
    type: 'pkcs8',
    format: 'pem'
  }
});

fs.writeFileSync('.keys/private.pem', privateKey);
fs.writeFileSync('.keys/public.pem', publicKey);

console.log('RSA key pair generated successfully!');
console.log('Add to .env: JWT_PRIVATE_KEY_PATH=.keys/private.pem');
console.log('Add to .env: JWT_PUBLIC_KEY_PATH=.keys/public.pem');
```

**Environment Variables:**
```env
JWT_PRIVATE_KEY_PATH=.keys/private.pem
JWT_PUBLIC_KEY_PATH=.keys/public.pem
```

**Add to .gitignore:**
```
.keys/
*.pem
```

### PKCE Implementation

**Code Verifier Generation (Client-side):**
```typescript
function generateCodeVerifier(): string {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return base64URLEncode(array);
}

function base64URLEncode(buffer: Uint8Array): string {
  return btoa(String.fromCharCode(...buffer))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}

async function generateCodeChallenge(verifier: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return base64URLEncode(new Uint8Array(hash));
}
```

**Code Challenge Verification (Server-side):**
```typescript
function verifyCodeChallenge(verifier: string, challenge: string): boolean {
  const hash = crypto.createHash('sha256').update(verifier).digest();
  const computedChallenge = base64URLEncode(hash);
  return computedChallenge === challenge;
}
```

---

## Security Considerations

### Threat Modeling

| Threat | Mitigation |
|--------|------------|
| **Authorization Code Interception** | PKCE (Proof Key for Code Exchange) |
| **CSRF on Authorization Endpoint** | State parameter validation |
| **Token Replay Attacks** | Short-lived access tokens (15min), JTI tracking |
| **Refresh Token Theft** | Token family rotation, revocation on reuse |
| **Client Impersonation** | Client secret hashing, HTTPS only |
| **Scope Escalation** | Role-based scope validation |
| **Open Redirect** | Strict redirect URI validation |
| **Session Fixation** | New session ID on login |

### Compliance Considerations

**GDPR:**
- User consent is explicit and recorded
- Users can view and revoke app authorizations
- Audit logs track data access
- Data minimization (return only requested scopes)

**OAuth 2.0 Best Practices (RFC 8252, RFC 8628):**
- PKCE required for public clients
- State parameter required
- Redirect URI exact matching (no wildcards)
- Short authorization code lifetime (10 minutes)

---

## Testing Strategy

### Unit Tests
- OAuth client validation logic
- PKCE challenge/verifier matching
- Scope validation rules
- Token generation/verification

### Integration Tests
- Complete authorization code flow
- Token refresh flow
- Token revocation
- Error handling (invalid clients, expired codes)

### End-to-End Tests
1. User logs into portal
2. Navigates to client app
3. Redirected to portal for consent
4. Grants permission
5. Redirected back with code
6. Client exchanges code for tokens
7. Client accesses user info
8. Client refreshes token
9. User revokes access in portal
10. Client's next request fails with 401

---

## Deployment Considerations

### Environment Variables

**New Variables:**
```env
# OAuth Configuration
JWT_PRIVATE_KEY_PATH=.keys/private.pem
JWT_PUBLIC_KEY_PATH=.keys/public.pem
OAUTH_ISSUER_URL=https://teamified-portal.repl.co
OAUTH_AUTHORIZATION_CODE_EXPIRY=600 # 10 minutes in seconds

# Feature Flags
OAUTH_ENABLED=true
OAUTH_PKCE_REQUIRED=true
```

### Database Migrations

**Using TypeORM:**
```bash
# Generate migration from entities
npm run migration:generate -- -n AddOAuthSupport

# Run migrations
npm run migration:run
```

### Monitoring

**Key Metrics:**
- OAuth token issuance rate
- Failed authorization attempts
- Average consent screen completion time
- Token refresh frequency
- Client usage statistics

**Alerts:**
- Spike in failed client authentications
- Authorization code reuse detected
- Unusual token revocation patterns

---

## Rollout Plan

### Phase 1: Infrastructure (Week 1-2)
- [ ] Create database entities
- [ ] Build OAuth client management (backend + admin UI)
- [ ] Generate RSA keys for production

### Phase 2: Core OAuth (Week 3-4)
- [ ] Implement authorization endpoint
- [ ] Implement token endpoint
- [ ] Add PKCE support
- [ ] Build consent screen UI

### Phase 3: OIDC (Week 5)
- [ ] Add discovery endpoint
- [ ] Implement UserInfo endpoint
- [ ] Generate ID tokens
- [ ] Set up JWKS endpoint

### Phase 4: Security & Polish (Week 6)
- [ ] Add scope system
- [ ] Implement token revocation
- [ ] Add rate limiting
- [ ] Enhance audit logging

### Phase 5: Client Integration (Week 7-8)
- [ ] Register 3 client apps
- [ ] Create integration documentation
- [ ] Build React auth hook library
- [ ] Integrate App 1
- [ ] Integrate App 2
- [ ] Integrate App 3

### Phase 6: Testing & Launch (Week 9)
- [ ] Complete E2E testing
- [ ] Security audit
- [ ] Performance testing
- [ ] Go live! üöÄ

---

## Success Metrics

**Technical:**
- [ ] All 3 apps successfully authenticate via portal
- [ ] Token refresh works seamlessly
- [ ] No authorization code reuse incidents
- [ ] PKCE validation passes for all flows
- [ ] 99.9% uptime for OAuth endpoints

**User Experience:**
- [ ] Average consent screen completion time < 10 seconds
- [ ] Users can manage authorized apps
- [ ] Zero forced logouts due to token issues

**Security:**
- [ ] Zero successful CSRF attacks
- [ ] All tokens properly revoked on logout
- [ ] Complete audit trail for all authorizations

---

## Future Enhancements (Post-MVP)

1. **Advanced Scopes**
   - Time-limited scopes (e.g., `payroll:read:1h`)
   - Context-specific scopes (e.g., `documents:read:employment`)

2. **Machine-to-Machine (M2M) Authentication**
   - Client credentials grant type
   - API keys for service accounts

3. **Multi-Factor Authentication**
   - Require MFA for sensitive scopes
   - Step-up authentication

4. **External Provider Support**
   - Allow users to link Google/Microsoft accounts
   - Social login integration

5. **Token Introspection**
   - RFC 7662 introspection endpoint
   - For resource servers to validate tokens

6. **Dynamic Client Registration**
   - RFC 7591 implementation
   - Self-service client registration

---

## Appendix

### Useful Resources

**OAuth 2.0:**
- RFC 6749: The OAuth 2.0 Authorization Framework
- RFC 7636: Proof Key for Code Exchange (PKCE)
- RFC 7662: Token Introspection
- RFC 8252: OAuth 2.0 for Native Apps

**OpenID Connect:**
- OpenID Connect Core 1.0
- OpenID Connect Discovery 1.0
- OIDC Certification: https://openid.net/certification/

**Implementation Guides:**
- Auth0 Blog: https://auth0.com/blog
- OAuth.com: https://www.oauth.com
- JWT.io: https://jwt.io

### Glossary

- **Access Token**: Short-lived JWT used to access protected resources
- **Authorization Code**: Temporary code exchanged for tokens
- **Client**: Application requesting user authorization
- **Code Challenge**: Hashed verifier used in PKCE
- **Code Verifier**: Random string generated by client for PKCE
- **Consent**: User's permission for client to access their data
- **ID Token**: JWT containing user identity claims (OIDC)
- **Refresh Token**: Long-lived token used to obtain new access tokens
- **Scope**: Permission to access specific resources
- **State**: Random value for CSRF protection

---

**Document End**

Last Updated: November 5, 2025  
Version: 1.0  
Author: Replit Agent  
Status: Planning Phase
